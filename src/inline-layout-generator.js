var InlineLayoutGenerator = (function(){
  function InlineLayoutGenerator(style, stream){
    LayoutGenerator.call(this, style, stream);
  }
  Class.extend(InlineLayoutGenerator, LayoutGenerator);

  InlineLayoutGenerator.prototype.popCache = function(context){
    var cache = LayoutGenerator.prototype.popCache.call(this, context);
    /*
    // restore inline context if measure changed from when this cache is pushed.
    if(this.hasChildLayout() && cache.display === "inline" && !cache.hasLineBreak){
      // restart line in larger measure context.
      if(cache.getBoxMeasure(this.style.flow) <= context.getInlineMaxMeasure()){
	return this.yield(context.restoreInlineContext(cache));
      }
      // restart line into shorter measure context, caused by float-layouting.
      // in description,
      //
      // 1. some float-layout has rest extent, and try to yield single line in that space but can't be included and cached.
      // 2. and when restart, measure of new layout has shorter measure than the cached line.
      //
      // to resolve this situation, we restart stream from the head of line.
      this.stream.setPos(cache.elements[0].pos); // TODO: if cache.elements[0] is not text object, it may trouble.
      this.clearCache(); // stream rewinded, so cache must be destroyed.
      return this.yield(context);
    }*/
    return cache;
  };
  

  InlineLayoutGenerator.prototype._yield = function(context){
    while(true){
      var element = this._getNext(context);
      if(element === null){
	break;
      }
      if(element instanceof Tag && element.getName() === "br"){
	context.setLineBreak(true);
	break;
      }
      var measure = this._getMeasure(element);
      //console.log("[%s] inline measure:%d", this.style.getMarkupName(), measure);
      if(context.getInlineCurMeasure() + measure > context.getInlineMaxMeasure()){
	//console.log("[%s] inline over and cached:%o", this.style.getMarkupName(), element);
	this.pushCache(element);
	break;
      }
      context.addInlineElement(element, measure);
    }
    // no br, no element
    if(context.isInlineEmpty()){
      //console.log("empty inline");
      return null;
    }
    // justify line if it's generated by not line-break but measure-overflow.
    if(!context.hasLineBreak()){
      this._justifyLine(context);
    }
    return this._createLine(context);
  };

  InlineLayoutGenerator.prototype._createChildContext = function(context){
    return new LayoutContext(
      context.block, // inline generator inherits block context as it is.
      new InlineLayoutContext(context.getInlineRestMeasure())
    );
  };

  InlineLayoutGenerator.prototype._justifyLine = function(context){
    var next_head = this.peekLastCache();
    var new_tail = context.justify(next_head);
    if(new_tail){
      this.stream.setPos(new_tail.pos + 1);
      this.clearCache(); // stream position changed, so disable cache.
    }
  };

  InlineLayoutGenerator.prototype._createLine = function(context){
    return this.style.createLine({
      hasLineBreak:context.hasLineBreak(),
      measure:(this.style.isRootLine()? this.style.getContentMeasure() : context.getInlineCurMeasure()),
      inlineMeasure:context.getInlineCurMeasure(),
      elements:context.getInlineElements(),
      texts:context.getInlineTexts(),
      charCount:context.getInlineCharCount()
    });
  };

  InlineLayoutGenerator.prototype._getNext = function(context){
    if(this.hasCache()){
      return this.popCache();
    }

    if(this.hasChildLayout()){
      return this.yieldChildLayout();
    }

    // read next token
    var token = this.stream.get();
    if(token === null){
      return null;
    }

    // if tag token, inherit style
    var style = this.style;
    if(token instanceof Tag){
      style = new StyleContext(token, this.style);
      //console.log("inline(%s) - new style(%s):%o, isBlock=%o", this.style.getMarkupName(), style.getMarkupName(), style, style.isBlock());

      // inline -> block, force terminate inline
      if(style.isBlock()){
	//console.log("inline -> block by %s", style.getMarkupName());
	this.stream.prev();
	this.setTerminate(true);
	return null;
      }
    }

    // inline text
    if(Token.isText(token)){
      return this._getText(context, token);
    }

    // inline tag(child inline)
    switch(token.getName()){
    case "br":
      return token;
    default:
      //console.log("start child inline:%s", token.getContent());
      this.setChildLayout(new InlineLayoutGenerator(style, this._createStream(token)));
      return this.yieldChildLayout(context);
    }
  };

  InlineLayoutGenerator.prototype._getText = function(context, token){
    if(!token.hasMetrics()){
      // if charactor token, set kerning before setting metrics.
      // because some additional space is added to it in some case.
      if(token instanceof Char){
	this._setCharKerning(context, token);
      }
      token.setMetrics(this.style.flow, this.style.font);
    }
    if(token instanceof Ruby){
      return token;
    }
    switch(token._type){
    case "char":
    case "tcy":
      return token;
      case "word":
      return this._getWord(context, token);
    }
  };

  InlineLayoutGenerator.prototype._setCharKerning = function(context, char_token){
    var next_token = this.stream.peek();
    var prev_text = context.getInlineLastText();
    var next_text = next_token && Token.isText(next_token)? next_token : null;
    Kerning.set(char_token, prev_text, next_text);
  };

  InlineLayoutGenerator.prototype._getWord = function(context, token){
    var rest_measure = context.getInlineRestMeasure();
    var advance = token.getAdvance(this.style.flow, this.style.letterSpacing || 0);
    
    // if advance of this word is less than max-measure, just return.
    if(advance <= rest_measure){
      token.setDevided(false);
      return token;
    }
    // if advance is lager than max_measure,
    // we must cut this word into some parts.
    var part = token.cutMeasure(this.style.font.size, rest_measure); // get sliced word
    part.setMetrics(this.style.flow, this.style.font); // metrics for first half
    token.setMetrics(this.style.flow, this.style.font); // metrics for second half
    this.stream.prev(); // re-parse this token because rest part is still exists.
    return part;
  };

  InlineLayoutGenerator.prototype._getMeasure = function(element){
    if(element instanceof Box){
      return element.getBoxMeasure(this.style.flow);
    }
    if(element.getAdvance){
      return element.getAdvance(this.style.flow, this.style.letterSpacing || 0);
    }
    return 0; // TODO
  };

  return InlineLayoutGenerator;
})();

